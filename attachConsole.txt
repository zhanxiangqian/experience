oidSkip到内容
从GUI应用程序发布到控制台
在Windows中，应用程序可以标记为GUI或控制台。 GUI应用程序具有带控件的窗口，控制台应用程序在黑盒子中运行，接收文本输入并生成文本输出。输入和输出可以重定向，允许链接应用程序并将结果写入文件：

dir |找到“.dll”> list_of_dlls.txt

对于不输出数据流的应用程序，控制台通常是打印状态消息的好方法。有两类应用程序可以从两种方式运行中受益：如果按原样运行，它们会显示GUI，但是使用命令行开关，它们可以静默地执行并退出。

myapp.exe  - 运行图形界面

myapp.exe / source dir1，dir2 / output dir3  - 以静默方式完成作业并退出

这些应用程序可以检测它们何时从控制台和输出状态消息运行？否则表现完全像一个控制台应用程序？

这是一个有趣而复杂的话题，这是我的发现。

背景
控制台和GUI子系统
每个EXE文件都有一个标志，将其标记为GUI或CONSOLE子系统应用程序（还有其他子系统，但它们对本文并不重要）。标记为控制台或GUI的应用程序表现不同。

控制台应用：

按原样运行时，为自己创建一个新的控制台窗口。
从其他控制台应用程序（例如cmd.exe）运行时，继承其控制台窗口，直到完成后才返回。
GUI应用程序：

当按原样运行时，是不可见的（直到他们手动创建一些GUI窗口）。
从控制台应用程序（如cmd.exe）运行时，立即返回控件并在后台运行。
然而，一旦开始，它们是相同的。它们可以调用相同的函数，它们具有相同的权限，就Windows而言，每个函数都可以重新配置为另一个。

一旦它们运行，控制台和GUI应用程序之间没有任何主要区别。

控制台
每个进程最多可以有一个连接的控制台。控制台是您键入输入和打印输出的窗口。当控制台标记的应用程序启动并且没有继承的控制台时，系统会自动创建它们。

每个控制台提供三个标准句柄，用于输入，输出和错误输出。它们如下所述传递给应用程序。当您写入输出/错误句柄时，该数据将显示在控制台中。当您从输入句柄中读取时，控制台允许用户键入一些字符并返回该字符。

连接控制台意味着您可以使用这些句柄。即使您以某种方式获得这些句柄，也没有附加控制台，它们将无法工作。

附件比这更深入：一旦控制台窗口关闭，所有附加的进程将被终止，并且无法阻止，尽管您可以收到通知并被允许完成。

当控制台标记的应用程序启动另一个控制台标记的应用程序时，后者继​​承控制台。没有创建新窗口，它接收相同的输入，输出和错误句柄。

GUI标记的应用程序永远不会继承控制台，无论它们如何启动。但他们仍然继承了手柄，这些手柄将被打破（见下文）。

默认情况下，现代系统控制台窗口由conhost.exe实现。但有些应用程序在安装时会替换它。

连接到控制台
任何应用程序（包括带有GUI标记的应用程序）都可以通过使用控制台（从中复制控制台）传递进程的进程ID来附加到具有AttachConsole（）的控制台。

如果两个应用程序连接到同一个控制台，则它们都可以读取和写入。除非他们协调，否则他们会产生一团糟。

任何应用程序都可以使用AllocConsole（）为自己创建一个新的控制台。这将生成一个新的控制台窗口，与Windows为控制台标记的应用程序自动创建的窗口相同。

实际上，对于控制台标记的应用程序，如果没有继承控制台，Windows就会自动调用它。

从控制台分离
任何应用程序（包括控制台标记的应用程序）都可以通过FreeConsole（）与控制台分离。在这种情况下，标准手柄停止工作。

是的，这意味着控制台应用程序可以停止成为控制台应用程序，如果愿意的话。

一旦没有人连接，控制台窗口就会自动销毁。如果您是唯一连接的（因为您使用AllocConsole（）创建了控制台，或者因为它是为您的控制台标记的进程自动创建的），一旦您使用FreeConsole（），窗口就会消失并继续运行。

如果您从父进程继承控制台或手动附加到控制台，它将保留其他进程。

标准手柄
要在控制台应用程序中输入和输出数据，Windows提供了三个读写句柄，可以从GetStdHandle（）获取：STD_INPUT_HANDLE，STD_OUTPUT_HANDLE和STD_ERROR_HANDLE。

这些是标准的Windows句柄，与CreateFile（）返回的句柄相同。

对于控制台应用程序，所有这些都指向附加的控制台。如果输入被重定向，它们将指向文件或管道到另一个应用程序。对于从资源管理器启动的GUI应用程序，所有将为零。